## Computed property(계산된 프로퍼티)

computed property name은 표현식(expression)을 이용해 객체의 key 값을 정의하는 문법

```jsx
let a = 'age';

const user = {
	name : 'Mike',
	age : 30 // age : 30
}

------------------------------------------------------------------------------

let a = 'age';

const user = {
	name : 'Mike',
	[a] : 30 // age : 30
}
// []로 묶어주면 문자열 a가 아니라 변수 a에 할당된 값이 들어감
```

언제 사용할까? 왜 사용하는 걸까? 좀 실용적으로 사용해보자 

key와 value을 받아 객체를 리턴하는 함수

```jsx
function makeObj(key, value){
	return {
		[key]:value,
	};
}
const obj = makeObj("나이", 33); // 첫 번째 인자 값이 key가 됨
console.log(obj); // { '나이': 33 }
```

## 객체 메소드

**Object.assign() : 객체 복제**

```jsx
객체 복제가 안되는 상황
user 변수에는 객체 자체가 들어가 있는 것이 아니라 
객체가 저장되어 있는 메모리 주소인 객체의 참조값이 저장됨
그래서 밑의 코드는 객체가 복사되는 것이 아니라 참조값만 복사가 되는것!
const user = {
	name : 'Mike',
	age : 30
}
const cloneUser = user;

-----------------
객체 복제가 되는 상황
const newUser = Object.assign({},user);//첫번째 인자는 초기값 두번째 인자부터 초기값에 병합
```

**Object.keys() : 키 배열 반환**

```jsx
const user = {
	name : 'Mike',
	age : 30,
	gender : 'male'
}
Object.keys(user);
// ["name", "age", "gender"]
```

**Object.values() : 값 배열 반환**

```jsx
const user = {
	name : 'Mike',
	age : 30,
	gender : 'male'
}
Object.values(user);
// ["Mike", "30", "male"]
```

**Object.entries() : 키/값 → 배열 반환**

```jsx
const user = {
	name : 'Mike',
	age : 30,
	gender : 'male'
}
Object.entries(user);
// [["name","Mike"], ["age", "30"], ["gender", "male"]]
```

**Object.fromEntries() : 배열 → 키/값 반환**

```jsx
const user = [
	["name", "Mike"],
	["age", "30"],
	["gender","male"]
]
Object.entries(user);
// {
//	name : 'Mike',
//	age : 30,
//	gender : 'male'
// }
```
